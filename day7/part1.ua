# Experimental!

ðŸ’¾  â† &fras "input.txt"
ðŸ—’ï¸ â† âŠœâ–¡âˆ˜Â¬âŠ¸â¦·@\nðŸ’¾
ðŸ—’ï¸

ParseRow â† â–¡ â‹• âŠœâ–¡âˆ˜Â¬âŠ¸â¦·@ â–½ Â¬ â¦·@: . Â°â–¡

# Combos ? SetofNumbers
FindCombos â† â—´ â§…â‰  â§» .

# SumAndProduct RestOfSet ? SetofNumbers
ProcessFirstCombo â† (
  âŠƒ(âŠ™â‹…âŠ™|â‹…âˆ˜) Â°âŠ‚ : Â°âŠ‚ # get first two elements, put on top of the stack
  âŠƒ(+|Ã—)            # get sum and product of them
  âŠŸ
)

# SumAndProduct RestOfSet ? SetOfNumbers
ProcessNextCombo â† (
  âŠƒ(âŠ™â‹…âŠ™|â‹…âˆ˜) Â°âŠ‚ : # get next element of the set, put on top of stack with sum/product set next
  âŠƒ(+|Ã—)         # get sum and product of these with the earlier ones
  âŠ‚              # join into one set
  â—´
)

NumberLeft â† (
  âŠƒ(âŠ™â‹…âŠ™|â‹…âˆ˜) â§» . âŠƒ(â‹…âˆ˜|âŠ™â‹…âŠ™) ? # return number of elements left in set
)

CheckAnswer â† (
  Ã—âŠƒ(>0/+âˆˆ :|â‹…âŠ™) âŠ™â‹…âŠ™ # find specified answer in the possible answer set
)

ProcessRow â† (
  Â°â–¡
  :Â°âŠ‚
  ProcessFirstCombo
  >0 NumberLeft
  â¨¬(âˆ˜|â¢(ProcessNextCombo|>0 NumberLeft))
  CheckAnswer
)
â‰¡ParseRow
# /+â‰¡ProcessRow
/+â‰¡ProcessRow
